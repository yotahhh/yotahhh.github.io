<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D CD Case Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }
        #controls {
            padding: 20px;
            text-align: center;
            z-index: 10;
        }
        input[type="file"] {
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        textarea {
            margin-left: 10px;
            width: 200px;
            height: 80px;
            background: #333;
            color: #fff;
            border: 2px solid #666;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }
        button {
            margin-left: 10px;
            padding: 10px 20px;
            background: #555;
            color: #fff;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #666;
        }
        #canvas {
            display: block;
            cursor: grab;
        }
        #canvas:active {
            cursor: grabbing;
        }
        #info {
            margin-top: 20px;
            font-size: 12px;
            color: #999;
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="imageUpload" accept="image/jpeg,image/jpg,image/png">
        <textarea id="tracklistInput" placeholder="Enter tracklist&#10;(one track per line)"></textarea>
        <button id="updateTracklist">Update Back</button>
        <div id="info">Upload cover • Enter tracklist • Drag to rotate</div>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        const vsSource = `
            attribute vec4 aPosition;
            attribute vec2 aTexCoord;
            attribute vec3 aNormal;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vViewPos;
            
            void main() {
                vec4 viewPos = uModelViewMatrix * aPosition;
                gl_Position = uProjectionMatrix * viewPos;
                vTexCoord = aTexCoord;
                vNormal = normalize((uNormalMatrix * vec4(aNormal, 0.0)).xyz);
                vViewPos = viewPos.xyz;
            }
        `;

        const fsSource = `
            precision highp float;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vViewPos;
            uniform sampler2D uSampler;
            uniform sampler2D uBackSampler;
            uniform int uMaterial;
            uniform int uHasBack;
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(-vViewPos);
                vec3 light1 = normalize(vec3(2.0, 3.0, 4.0));
                vec3 light2 = normalize(vec3(-1.5, 1.0, 2.0));
                float diff1 = max(dot(normal, light1), 0.0);
                float diff2 = max(dot(normal, light2), 0.0) * 0.5;
                vec3 halfDir1 = normalize(light1 + viewDir);
                float spec1 = pow(max(dot(normal, halfDir1), 0.0), 64.0);
                float ambient = 0.3;
                
                if (uMaterial == 0) {
                    // Front booklet
                    vec4 tex = texture2D(uSampler, vTexCoord);
                    float light = ambient + diff1 * 0.65 + diff2 * 0.35;
                    gl_FragColor = vec4(tex.rgb * light, 1.0);
                } else if (uMaterial == 5) {
                    // Back insert - respect alpha channel for transparency
                    vec4 tex;
                    if (uHasBack == 1) {
                        // Custom text with transparent background
                        tex = texture2D(uBackSampler, vTexCoord);
                    } else {
                        // Cover image (opaque)
                        tex = texture2D(uSampler, vTexCoord);
                        tex.a = 1.0;
                    }
                    float light = ambient + diff1 * 0.65 + diff2 * 0.35;
                    gl_FragColor = vec4(tex.rgb * light, tex.a);
                } else if (uMaterial == 1) {
                    // Transparent plastic - cheap plastic look with slight color tint
                    float ndotv = abs(dot(normal, viewDir));
                    float fresnel = pow(1.0 - ndotv, 4.0);
                    fresnel = mix(0.03, 0.25, fresnel);
                    
                    // Slight blue-gray tint for cheap plastic
                    vec3 plasticTint = vec3(0.88, 0.90, 0.92);
                    vec3 color = plasticTint * (ambient * 0.4 + diff1 * 0.25 + diff2 * 0.15);
                    
                    // Sharp specular for glossy plastic
                    color += vec3(1.0) * spec1 * 0.9;
                    
                    gl_FragColor = vec4(color, 0.08 + fresnel);
                } else if (uMaterial == 2) {
                    // CD tray
                    float ndotv = abs(dot(normal, viewDir));
                    float fresnel = pow(1.0 - ndotv, 2.0);
                    vec3 color = vec3(0.08, 0.08, 0.1) * (ambient * 0.7 + diff1 * 0.4 + diff2 * 0.25);
                    color += vec3(1.0) * spec1 * 0.4;
                    gl_FragColor = vec4(color, 0.5 + fresnel * 0.3);
                } else {
                    // Edges
                    float ndotv = abs(dot(normal, viewDir));
                    float fresnel = pow(1.0 - ndotv, 3.0);
                    vec3 color = vec3(0.9, 0.92, 0.94) * (ambient * 0.6 + diff1 * 0.3 + diff2 * 0.2);
                    color += vec3(1.0) * spec1 * 0.6;
                    gl_FragColor = vec4(color, 0.15 + fresnel * 0.25);
                }
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);

        const loc = {
            attr: {
                position: gl.getAttribLocation(program, 'aPosition'),
                texCoord: gl.getAttribLocation(program, 'aTexCoord'),
                normal: gl.getAttribLocation(program, 'aNormal'),
            },
            uni: {
                projection: gl.getUniformLocation(program, 'uProjectionMatrix'),
                modelView: gl.getUniformLocation(program, 'uModelViewMatrix'),
                normalMat: gl.getUniformLocation(program, 'uNormalMatrix'),
                sampler: gl.getUniformLocation(program, 'uSampler'),
                backSampler: gl.getUniformLocation(program, 'uBackSampler'),
                material: gl.getUniformLocation(program, 'uMaterial'),
                hasBack: gl.getUniformLocation(program, 'uHasBack'),
            },
        };

        const w = 1.42, h = 1.25, d = 0.1;
        const spineW = 0.14;

        function quad(p, t, n, v1, v2, v3, v4, norm, tex = false) {
            p.push(...v1, ...v2, ...v3, ...v1, ...v3, ...v4);
            if (tex) t.push(0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0);
            else for (let i = 0; i < 6; i++) t.push(0, 0);
            for (let i = 0; i < 6; i++) n.push(...norm);
        }

        function createGeometry() {
            const geoms = [];
            
            // Front booklet (doesn't reach left spine)
            {
                const p = [], t = [], n = [];
                const z = d/2 - 0.02;
                quad(p, t, n,
                    [-w/2 + spineW + 0.015, -h/2 + 0.015, z],
                    [w/2 - 0.015, -h/2 + 0.015, z],
                    [w/2 - 0.015, h/2 - 0.015, z],
                    [-w/2 + spineW + 0.015, h/2 - 0.015, z],
                    [0, 0, 1], true);
                geoms.push({p, t, n, mat: 0});
            }
            
            // Back insert (full size)
            {
                const p = [], t = [], n = [];
                const z = -d/2 + 0.003;
                quad(p, t, n,
                    [w/2, -h/2, z],
                    [-w/2, -h/2, z],
                    [-w/2, h/2, z],
                    [w/2, h/2, z],
                    [0, 0, -1], true);
                geoms.push({p, t, n, mat: 5});
            }
            
            // Plastic front
            {
                const p = [], t = [], n = [];
                quad(p, t, n, [-w/2, -h/2, d/2], [w/2, -h/2, d/2], [w/2, h/2, d/2], [-w/2, h/2, d/2], [0, 0, 1]);
                geoms.push({p, t, n, mat: 1});
            }
            
            // Plastic back
            {
                const p = [], t = [], n = [];
                quad(p, t, n, [w/2, -h/2, -d/2], [-w/2, -h/2, -d/2], [-w/2, h/2, -d/2], [w/2, h/2, -d/2], [0, 0, -1]);
                geoms.push({p, t, n, mat: 1});
            }
            
            // CD tray - removed to avoid visible borders through transparent back
            
            // Edges
            const edges = [
                {v: [[w/2, -h/2, d/2], [w/2, -h/2, -d/2], [w/2, h/2, -d/2], [w/2, h/2, d/2]], n: [1, 0, 0]},
                {v: [[-w/2, h/2, d/2], [w/2, h/2, d/2], [w/2, h/2, -d/2], [-w/2, h/2, -d/2]], n: [0, 1, 0]},
                {v: [[-w/2, -h/2, -d/2], [w/2, -h/2, -d/2], [w/2, -h/2, d/2], [-w/2, -h/2, d/2]], n: [0, -1, 0]},
                {v: [[-w/2, -h/2, -d/2], [-w/2, -h/2, d/2], [-w/2, h/2, d/2], [-w/2, h/2, -d/2]], n: [-1, 0, 0]},
            ];
            edges.forEach(e => {
                const p = [], t = [], n = [];
                quad(p, t, n, ...e.v, e.n);
                geoms.push({p, t, n, mat: 4});
            });
            
            return geoms.map(g => {
                const buffers = [g.p, g.t, g.n].map(data => {
                    const buf = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
                    return buf;
                });
                return {pos: buffers[0], tex: buffers[1], norm: buffers[2], count: g.p.length / 3, mat: g.mat};
            });
        }

        const buffers = createGeometry();
        let texture = null, backTexture = null, rotation = 0.3, autoRotate = true, lastTime = Date.now();

        function perspective(fov, aspect, near, far) {
            const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
            return [f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0];
        }

        function mat4() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; }

        function translate(m, v) {
            const out = [...m];
            out[12] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12];
            out[13] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13];
            out[14] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14];
            return out;
        }

        function rotateY(m, a) {
            const s = Math.sin(a), c = Math.cos(a);
            const out = [...m];
            out[0] = m[0] * c - m[8] * s;
            out[1] = m[1] * c - m[9] * s;
            out[2] = m[2] * c - m[10] * s;
            out[8] = m[0] * s + m[8] * c;
            out[9] = m[1] * s + m[9] * c;
            out[10] = m[2] * s + m[10] * c;
            return out;
        }

        function invert(m) {
            const a = m, out = [], det = a[0] * (a[5] * a[10] - a[6] * a[9]) - a[1] * (a[4] * a[10] - a[6] * a[8]) + a[2] * (a[4] * a[9] - a[5] * a[8]);
            const invDet = 1 / det;
            out[0] = (a[5] * a[10] - a[6] * a[9]) * invDet;
            out[1] = -(a[1] * a[10] - a[2] * a[9]) * invDet;
            out[2] = (a[1] * a[6] - a[2] * a[5]) * invDet;
            out[4] = -(a[4] * a[10] - a[6] * a[8]) * invDet;
            out[5] = (a[0] * a[10] - a[2] * a[8]) * invDet;
            out[6] = -(a[0] * a[6] - a[2] * a[4]) * invDet;
            out[8] = (a[4] * a[9] - a[5] * a[8]) * invDet;
            out[9] = -(a[0] * a[9] - a[1] * a[8]) * invDet;
            out[10] = (a[0] * a[5] - a[1] * a[4]) * invDet;
            return [out[0], out[1], out[2], 0, out[4], out[5], out[6], 0, out[8], out[9], out[10], 0, 0, 0, 0, 1];
        }

        function transpose(m) {
            return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
        }

        function draw() {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            const proj = perspective(45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100);
            const mv = rotateY(translate(mat4(), [0, 0, -3.5]), rotation);
            const norm = transpose(invert(mv));

            gl.useProgram(program);
            gl.uniformMatrix4fv(loc.uni.projection, false, proj);
            gl.uniformMatrix4fv(loc.uni.modelView, false, mv);
            gl.uniformMatrix4fv(loc.uni.normalMat, false, norm);
            gl.uniform1i(loc.uni.hasBack, backTexture ? 1 : 0);

            if (texture) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(loc.uni.sampler, 0);
            }
            if (backTexture) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, backTexture);
                gl.uniform1i(loc.uni.backSampler, 1);
            }

            // Opaque (front booklet and back when showing cover)
            buffers.forEach(b => {
                if (b.mat === 0 || (b.mat === 5 && !backTexture)) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.pos);
                    gl.vertexAttribPointer(loc.attr.position, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.position);
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.tex);
                    gl.vertexAttribPointer(loc.attr.texCoord, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.texCoord);
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.norm);
                    gl.vertexAttribPointer(loc.attr.normal, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.normal);
                    gl.uniform1i(loc.uni.material, b.mat);
                    gl.drawArrays(gl.TRIANGLES, 0, b.count);
                }
            });

            // Transparent (includes back insert when text is added)
            gl.depthMask(false);
            buffers.forEach(b => {
                if (b.mat === 1 || b.mat === 4 || (b.mat === 5 && backTexture)) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.pos);
                    gl.vertexAttribPointer(loc.attr.position, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.position);
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.tex);
                    gl.vertexAttribPointer(loc.attr.texCoord, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.texCoord);
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.norm);
                    gl.vertexAttribPointer(loc.attr.normal, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc.attr.normal);
                    gl.uniform1i(loc.uni.material, b.mat);
                    gl.drawArrays(gl.TRIANGLES, 0, b.count);
                }
            });
            gl.depthMask(true);
        }

        function animate() {
            if (autoRotate) {
                const now = Date.now();
                rotation += ((now - lastTime) / 1000) * 0.3;
                lastTime = now;
                draw();
            }
            requestAnimationFrame(animate);
        }

        function loadTexture(img) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            return tex;
        }

        document.getElementById('imageUpload').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = () => { texture = loadTexture(img); draw(); };
                img.src = URL.createObjectURL(file);
            }
        });

        function createBackTexture(text) {
            const c = document.createElement('canvas');
            c.width = c.height = 512;
            const ctx = c.getContext('2d');
            
            // Very transparent black background
            ctx.clearRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, 512, 512);
            
            // Fully opaque white text
            ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
            ctx.font = '24px Arial';
            const lines = text.split('\n');
            lines.forEach((line, i) => {
                if (line.trim()) ctx.fillText(line.trim(), 50, 50 + i * 32);
            });
            const img = new Image();
            img.onload = () => { backTexture = loadTexture(img); draw(); };
            img.src = c.toDataURL();
        }

        document.getElementById('updateTracklist').addEventListener('click', () => {
            const text = document.getElementById('tracklistInput').value;
            if (text.trim()) createBackTexture(text);
        });

        document.getElementById('tracklistInput').addEventListener('keydown', e => {
            if (e.key === 'Enter' && e.ctrlKey) {
                const text = e.target.value;
                if (text.trim()) createBackTexture(text);
            }
        });

        let dragging = false, lastX = 0;
        canvas.addEventListener('mousedown', e => { dragging = true; autoRotate = false; lastX = e.clientX; });
        canvas.addEventListener('mousemove', e => {
            if (dragging) {
                rotation += (e.clientX - lastX) * 0.01;
                lastX = e.clientX;
                lastTime = Date.now();
                draw();
            }
        });
        canvas.addEventListener('mouseup', () => {
            dragging = false;
            setTimeout(() => { if (!dragging) { autoRotate = true; lastTime = Date.now(); } }, 2000);
        });
        canvas.addEventListener('mouseleave', () => {
            dragging = false;
            setTimeout(() => { if (!dragging) { autoRotate = true; lastTime = Date.now(); } }, 2000);
        });

        animate();
    </script>
</body>
</html>